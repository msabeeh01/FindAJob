Ö®DateTime◊ˇL˙9¿e‡)™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$99d6b647-cf37-4f97-9b3c-101cd637e438®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$9fff9ae9-1b1a-43ce-8a17-78bad2e710d1Ÿ$b7dfd5d5-0b89-41cb-a535-30bb5f9fdee8öÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$9fff9ae9-1b1a-43ce-8a17-78bad2e710d1©Reference©#solution•Value»ÆdŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContentŸï
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Builder;
using Microsoft.IdentityModel.Tokens;
using System.Text;ØOriginalContent¿™Selectionsê®FilePathŸGD:\Winter Semester 2024\Portfolio Projects 2\FindAJob\server\Startup.cs®Language¢C#ÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$9fff9ae9-1b1a-43ce-8a17-78bad2e710d1©Reference©#solution•Value»ıdŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContentŸ‹
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            // tell the app to use authentication
            app.UseAuthentication();
            app.UseAuthorization();
        }ØOriginalContent¿™Selectionsê®FilePathŸGD:\Winter Semester 2024\Portfolio Projects 2\FindAJob\server\Startup.cs®Language¢C#ÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$9fff9ae9-1b1a-43ce-8a17-78bad2e710d1©Reference©#solution•Value»ÇdŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄U
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.JsonWebTokens;
using Microsoft.IdentityModel.Tokens;
using server.DTO;
using server.Models.TestModel;
using server.Models.UserModel;
using System.IdentityModel.Tokens.Jwt;
using System.Text;ØOriginalContent¿™Selectionsê®FilePathŸZD:\Winter Semester 2024\Portfolio Projects 2\FindAJob\server\Controllers\UserController.cs®Language¢C#ÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$9fff9ae9-1b1a-43ce-8a17-78bad2e710d1©Reference©#solution•Value»ÀdŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄±
public void ConfigureServices(IServiceCollection services)
        {
            //authentication middleware setup
            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                .AddJwtBearer(options =>
                {
                    options.TokenValidationParameters = new TokenValidationParameters
                    {
                        ValidateIssuer = true,
                        ValidateAudience = true,
                        ValidateLifetime = false,
                        ValidateIssuerSigningKey = true,

                        //reference to apppsettings jwt object
                        //{
                        //  "Jwt":{
                        //      "Key": "SECRET",
                        //      "Issuer": "https://localhost:5001",
                        //  }
                        //}
                        ValidIssuer = Configuration["Jwt:Issuer"],
                        ValidAudience = Configuration["Jwt:Issuer"],
                        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration["Jwt:Key"]))

                    };
                });
        }ØOriginalContent¿™Selectionsê®FilePathŸGD:\Winter Semester 2024\Portfolio Projects 2\FindAJob\server\Startup.cs®Language¢C#ÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$9fff9ae9-1b1a-43ce-8a17-78bad2e710d1©Reference©#solution•Value»ædŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄ë
private string GenerateJSONWebToken(UserLoginDto user)
        {
            //create sec key using the secret key from appsettings.json
            var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config["Jwt:Key"]));
            //create credentials using the sec key and algorithm
            var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);

            //create the token
            var token = new JwtSecurityToken(_config["Jwt:Issuer"],
                      _config["Jwt:Issuer"],
                                          null,
                                                       expires: DateTime.Now.AddMinutes(120),
                                                                    signingCredentials: credentials);
            //return the token
            return new JwtSecurityTokenHandler().WriteToken(token);
        }ØOriginalContent¿™Selectionsê®FilePathŸZD:\Winter Semester 2024\Portfolio Projects 2\FindAJob\server\Controllers\UserController.cs®Language¢C#ÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$9fff9ae9-1b1a-43ce-8a17-78bad2e710d1©Reference©#solution•Value»ídŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContentŸf
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using server.Models.TestModel;ØOriginalContent¿™Selectionsê®FilePathŸZD:\Winter Semester 2024\Portfolio Projects 2\FindAJob\server\Controllers\TestController.cs®Language¢C#ÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$9fff9ae9-1b1a-43ce-8a17-78bad2e710d1©Reference©#solution•Value»òdŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContentŸl
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using server.Models.JobsModel;
using System.Text;ØOriginalContent¿™Selectionsê®FilePathŸZD:\Winter Semester 2024\Portfolio Projects 2\FindAJob\server\Controllers\JobsController.cs®Language¢C#ÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$9fff9ae9-1b1a-43ce-8a17-78bad2e710d1©Reference©#solution•Value»]dŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄0// login user and return jwt token
[HttpPost("login")]
        public async Task<IActionResult> Login([FromBody]UserLoginDto login)
        {
            //find user by name
            var user = await _context.Users.FirstOrDefaultAsync(u => u.username == login.username);

            //if user not found
            if (user == null)
            {
                return BadRequest("Invalid username or password");
            }

            //if password is incorrect
            if (user.password != login.password)
            {
                return BadRequest("Invalid username or password");
            }

            //create jwt token
            var token = GenerateJSONWebToken(login);

            //return the token as an object
            return Ok(new { token });
        }ØOriginalContent¿™Selectionsê®FilePathŸZD:\Winter Semester 2024\Portfolio Projects 2\FindAJob\server\Controllers\UserController.cs®Language¢C#ÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$9fff9ae9-1b1a-43ce-8a17-78bad2e710d1©Reference©#solution•Value»edŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄8
[HttpGet]
        public async Task<ActionResult<IEnumerable<Test>>> GetTests()
        {
            try
            {
                return await _context.Tests.ToListAsync();
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }ØOriginalContent¿™Selectionsê®FilePathŸZD:\Winter Semester 2024\Portfolio Projects 2\FindAJob\server\Controllers\TestController.cs®Language¢C#ÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$9fff9ae9-1b1a-43ce-8a17-78bad2e710d1©Reference©#solution•Value»ádŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄Z// GET: api/<UserController>
[HttpGet]
        public async Task<ActionResult<IEnumerable<User>>> GetUsers()
        {
            try
            {
                return await _context.Users.ToListAsync<User>();
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }ØOriginalContent¿™Selectionsê®FilePathŸZD:\Winter Semester 2024\Portfolio Projects 2\FindAJob\server\Controllers\UserController.cs®Language¢C#ëíìÅ•Value ⁄LSystem.InvalidOperationException: No authenticationScheme was specified, and there was no DefaultChallengeScheme found. The default schemes can be set using either AddAuthentication(string defaultScheme) or AddAuthentication(Action<AuthenticationOptions> configureOptions).
   at Microsoft.AspNetCore.Authentication.AuthenticationService.ChallengeAsync(HttpContext context, String scheme, AuthenticationProperties properties)
   at Microsoft.AspNetCore.Authorization.Policy.AuthorizationMiddlewareResultHandler.<>c__DisplayClass0_0.<<HandleAsync>g__Handle|0>d.MoveNext()
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)
   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)
   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)

HEADERS
=======
Accept: text/plain
Connection: keep-alive
Host: localhost:5121
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 OPR/107.0.0.0
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MDkxODk3MTAsImlzcyI6ImxvY2FsaG9zdCIsImF1ZCI6ImxvY2FsaG9zdCJ9.P5_l96yuSRdMSooUT5fK9cLqiQPZkXNUYTutZEB32AY
Referer: http://localhost:5121/swagger/index.html
sec-ch-ua: "Not A(Brand";v="99", "Opera GX";v="107", "Chromium";v="121"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "Windows"
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty

#solution ¿®ResponseÖßContent⁄The error message indicates that no default authentication scheme has been set. In your `ConfigureServices` method, you are setting up JWT authentication but not setting it as the default scheme. 

You can fix this by specifying the default scheme when adding authentication services. Here's how you can do it:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication(options =>
    {
        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
        options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
    })
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = false,
            ValidateIssuerSigningKey = true,
            ValidIssuer = Configuration["Jwt:Issuer"],
            ValidAudience = Configuration["Jwt:Issuer"],
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration["Jwt:Key"]))
        };
    });
}
```

In the above code, `DefaultAuthenticateScheme` and `DefaultChallengeScheme` are set to `JwtBearerDefaults.AuthenticationScheme`. This tells ASP.NET Core to use JWT authentication by default.§Type ¶StatusØFollowUpPromptsê≥CodeVulnerabilitiesêÖ®DateTime◊ˇ¬Yˆe‡v™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$99d6b647-cf37-4f97-9b3c-101cd637e438®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$fdc1df77-14f2-4593-bd70-c822a0556a48Ÿ$59c35dfc-fe77-4253-b5b6-e170739dfd93êëíìÅ•Value ⁄ZSystem.InvalidOperationException: No authenticationScheme was specified, and there was no DefaultChallengeScheme found. The default schemes can be set using either AddAuthentication(string defaultScheme) or AddAuthentication(Action<AuthenticationOptions> configureOptions).
   at Microsoft.AspNetCore.Authentication.AuthenticationService.ChallengeAsync(HttpContext context, String scheme, AuthenticationProperties properties)
   at Microsoft.AspNetCore.Authorization.Policy.AuthorizationMiddlewareResultHandler.<>c__DisplayClass0_0.<<HandleAsync>g__Handle|0>d.MoveNext()
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)
   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)
   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)

HEADERS
=======
Accept: text/plain
Connection: keep-alive
Host: localhost:5121
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 OPR/107.0.0.0
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MDkxODk3MTAsImlzcyI6ImxvY2FsaG9zdCIsImF1ZCI6ImxvY2FsaG9zdCJ9.P5_l96yuSRdMSooUT5fK9cLqiQPZkXNUYTutZEB32AY
Referer: http://localhost:5121/swagger/index.html
sec-ch-ua: "Not A(Brand";v="99", "Opera GX";v="107", "Chromium";v="121"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "Windows"
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty

still getting this error¿®ResponseÖßContent⁄”The error message indicates that the authentication scheme is not specified. This is usually because the `UseAuthentication` and `UseAuthorization` middleware are not in the correct order in the `Configure` method, or they are missing.

In your `Configure` method, make sure that `UseAuthentication` and `UseAuthorization` are placed after `UseRouting` and before `UseEndpoints`. Here's how you can do it:

```csharp
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    // other middleware...

    app.UseRouting();

    // place UseAuthentication and UseAuthorization after UseRouting
    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        // endpoints.MapControllers(); or other mapping
    });
}
```

The order of middleware in ASP.NET Core is very important. The `UseAuthentication` and `UseAuthorization` middleware must be placed after `UseRouting` and before `UseEndpoints` to function correctly.§Type ¶StatusØFollowUpPromptsê≥CodeVulnerabilitiesêÖ®DateTime◊ˇ#õ’ e‡≈™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$99d6b647-cf37-4f97-9b3c-101cd637e438®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$5a159ab5-e1cf-4922-9a92-39a3396ff31eŸ$3e497b0f-ae2e-4257-8140-81b880a6bddbêëíìÅ•Value Ÿ]okay so im using both startup.cs and program.cs it seems like its only recognizing program.cs¿®ResponseÖßContent⁄In .NET 6, the new minimal hosting model was introduced, which allows you to configure your application in the `Program.cs` file without needing a `Startup.cs` file. If you're using .NET 6, it's likely that your `Startup.cs` file is being ignored.

Here's how you can configure authentication and authorization in the `Program.cs` file:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = false,
        ValidateIssuerSigningKey = true,
        ValidIssuer = builder.Configuration["Jwt:Issuer"],
        ValidAudience = builder.Configuration["Jwt:Issuer"],
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))
    };
});

builder.Services.AddControllers();

var app = builder.Build();

// Configure the HTTP request pipeline.
app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

app.UseEndpoints(endpoints =>
{
    endpoints.MapControllers();
});

app.Run();
```

This code does the same thing as the previous examples, but in the `Program.cs` file. It sets up JWT authentication and configures the middleware in the correct order.§Type ¶StatusØFollowUpPromptsíŸ>How can I secure my endpoints using the [Authorize] attribute?Ÿ<Can I use multiple authentication schemes in my application?≥CodeVulnerabilitiesëÜ¢Id ´StartOffset ©EndOffset §Type≥FallbackDisplayTypeµHardcoded Credentials∫FallbackDisplayDescriptionŸ>Embedding credentials in source code risks unauthorized accessÖ®DateTime◊ˇ©‹« e‡¸™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$99d6b647-cf37-4f97-9b3c-101cd637e438®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$9feb6d13-b10e-4f64-9e57-3b24c153fbb4Ÿ$aaaf77bf-23dc-4daf-9bb0-8a90569565d3êëíìÅ•Value ŸHokay now how do i decode the token to get the information i want from it¿®ResponseÖßContent⁄ëTo decode a JWT token and extract the information (claims) from it, you can use the `JwtSecurityTokenHandler` class provided by the `System.IdentityModel.Tokens.Jwt` namespace. Here's an example:

```csharp
using System.IdentityModel.Tokens.Jwt;

string token = "Your JWT token here";
var handler = new JwtSecurityTokenHandler();
var jwtToken = handler.ReadJwtToken(token);

// Get claims
var claims = jwtToken.Claims;
foreach (var claim in claims)
{
    Console.WriteLine($"Claim Type: {claim.Type}, Claim Value: {claim.Value}");
}
```

In this code, `handler.ReadJwtToken(token)` reads the JWT token and returns a `JwtSecurityToken` object. The `Claims` property of this object is a collection of all the claims in the token. Each claim has a `Type` and `Value` property that you can use to get the information you want.

Remember to replace `"Your JWT token here"` with the actual JWT token you want to decode.§Type ¶StatusØFollowUpPromptsíŸ4How can I validate the JWT token before decoding it?Ÿ1Can I extract specific claims from the JWT token?≥CodeVulnerabilitiesëÜ¢Id ´StartOffset ©EndOffset §Type≥FallbackDisplayTypeµHardcoded Credentials∫FallbackDisplayDescriptionŸ>Embedding credentials in source code risks unauthorized accessÖ®DateTime◊ˇ≤pe‡™ThreadName¿∞CopilotSessionIdÇ§GuidŸ$99d6b647-cf37-4f97-9b3c-101cd637e438®ClientIdÅ¢IdŸ4Microsoft.VisualStudio.Conversations.Chat.HelpWindowßRequestÅßRequestïŸ$f6e8075c-ffc4-4f35-a992-14133f81e2c2Ÿ$014c839a-23aa-4c83-84c2-bb37aa178a1fëÜØProviderMonikerÇ§NameŸ6Microsoft.VisualStudio.Copilot.DocumentContextProviderßVersion£0.1¶Member§file©CanReduce√©RequestIdŸ$f6e8075c-ffc4-4f35-a992-14133f81e2c2©Reference¿•Value»ƒdŸëMicrosoft.VisualStudio.Copilot.DocumentContext, Microsoft.VisualStudio.Copilot, Version=0.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aÖßContent⁄using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.JsonWebTokens;
using Microsoft.IdentityModel.Tokens;
using server.DTO;
using server.Models.TestModel;
using server.Models.UserModel;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

// For more information on enabling Web API for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860

namespace server.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class UserController : ControllerBase
    {
        private readonly TestContext _context;
        //give access to configuration settings
        private IConfiguration _config;

        public UserController(TestContext context, IConfiguration config)
        {
            _context = context;
            _config = config;
        }

        private string GenerateJSONWebToken(UserLoginDto user)
        {
            //create claims with information containing the user
            var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config["Jwt:Key"]));
            var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);

            var claims = new[]
            {
                new Claim("username", user.username),
            };

            var token = new JwtSecurityToken(_config["Jwt:Issuer"],
                             _config["Jwt:Issuer"],
                                          claims,
                                                       expires: DateTime.Now.AddMinutes(120),
                                                                    signingCredentials: credentials);

            return new JwtSecurityTokenHandler().WriteToken(token);
        }

        // login user and return jwt token
        [HttpPost("login")]
        public async Task<IActionResult> Login([FromBody]UserLoginDto login)
        {
            //find user by name
            var user = await _context.Users.FirstOrDefaultAsync(u => u.username == login.username);

            //if user not found
            if (user == null)
            {
                return BadRequest("Invalid username or password");
            }

            //if password is incorrect
            if (user.password != login.password)
            {
                return BadRequest("Invalid username or password");
            }

            //create jwt token
            var token = GenerateJSONWebToken(login);

            //return the token as an object
            return Ok(new { token });
        }


        // GET: api/<UserController>
        [HttpGet]
        public async Task<ActionResult<IEnumerable<User>>> GetUsers()
        {
            try
            {
                return await _context.Users.ToListAsync<User>();
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }

        // GET api/<UserController>/5
        // use the token provided
        [Authorize]
        [HttpGet("{name}")]
        public async Task<ActionResult<User>> GetUser(string name)
        {
            //get the user by decoding token
            var handler = new JwtSecurityTokenHandler();
            var token = handler.ReadJwtToken(Request.Headers["Authorization"].ToString().Split(" ")[1]);
            try
            {
                var user = await _context.Users.FirstOrDefaultAsync(u => u.username == name);
                if (user == null)
                {
                    return NotFound();
                }
                //return the decoded token
                return Ok(token.Payload.username);
            }
            catch (Exception e)
            {
                return BadRequest(e);
            }
        }   

        // POST api/<UserController>
        [HttpPost]
        public void Post([FromBody] string value)
        {
        }


        // DELETE api/<UserController>/5
        [HttpDelete("{id}")]
        public void Delete(int id)
        {
        }
    }
}
ØOriginalContent¿™SelectionsëÉ•Caret¿•StartÕ≥£EndÕÂ®FilePathŸZD:\Winter Semester 2024\Portfolio Projects 2\FindAJob\server\Controllers\UserController.cs®Language¢C#ëíìÅ•Value ⁄	e{
  "actor": null,
  "audiences": [
    "localhost"
  ],
  "claims": [
    {
      "issuer": "localhost",
      "originalIssuer": "localhost",
      "properties": {},
      "subject": null,
      "type": "username",
      "value": "msabeeh01",
      "valueType": "http://www.w3.org/2001/XMLSchema#string"
    },
    {
      "issuer": "localhost",
      "originalIssuer": "localhost",
      "properties": {},
      "subject": null,
      "type": "exp",
      "value": "1709191891",
      "valueType": "http://www.w3.org/2001/XMLSchema#integer64"
    },
    {
      "issuer": "localhost",
      "originalIssuer": "localhost",
      "properties": {},
      "subject": null,
      "type": "iss",
      "value": "localhost",
      "valueType": "http://www.w3.org/2001/XMLSchema#string"
    },
    {
      "issuer": "localhost",
      "originalIssuer": "localhost",
      "properties": {},
      "subject": null,
      "type": "aud",
      "value": "localhost",
      "valueType": "http://www.w3.org/2001/XMLSchema#string"
    }
  ],
  "encodedHeader": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
  "encodedPayload": "eyJ1c2VybmFtZSI6Im1zYWJlZWgwMSIsImV4cCI6MTcwOTE5MTg5MSwiaXNzIjoibG9jYWxob3N0IiwiYXVkIjoibG9jYWxob3N0In0",
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "id": null,
  "issuer": "localhost",
  "payload": {
    "username": "msabeeh01",
    "exp": 1709191891,
    "iss": "localhost",
    "aud": "localhost"
  },
  "innerToken": null,
  "rawAuthenticationTag": null,
  "rawCiphertext": null,
  "rawData": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Im1zYWJlZWgwMSIsImV4cCI6MTcwOTE5MTg5MSwiaXNzIjoibG9jYWxob3N0IiwiYXVkIjoibG9jYWxob3N0In0.15Mb-BtRgRzT2RwXVdflVvq2IGy4rACfKvKHRY3CSCc",
  "rawEncryptedKey": null,
  "rawInitializationVector": null,
  "rawHeader": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
  "rawPayload": "eyJ1c2VybmFtZSI6Im1zYWJlZWgwMSIsImV4cCI6MTcwOTE5MTg5MSwiaXNzIjoibG9jYWxob3N0IiwiYXVkIjoibG9jYWxob3N0In0",
  "rawSignature": "15Mb-BtRgRzT2RwXVdflVvq2IGy4rACfKvKHRY3CSCc",
  "securityKey": null,
  "signatureAlgorithm": "HS256",
  "signingCredentials": null,
  "encryptingCredentials": null,
  "signingKey": null,
  "subject": null,
  "validFrom": "0001-01-01T00:00:00",
  "validTo": "2024-02-29T07:31:31Z",
  "issuedAt": "0001-01-01T00:00:00"
}

how can i get the username in the payload¿®ResponseÖßContent⁄‘The `JwtSecurityToken` object has a `Claims` property which is a collection of all the claims in the token. Each claim has a `Type` and `Value` property. You can use these properties to get the username from the token.

Here's how you can do it:

```csharp
var usernameClaim = token.Claims.FirstOrDefault(c => c.Type == "username");
if (usernameClaim != null)
{
    var username = usernameClaim.Value;
    // Now you can use the username
}
```

In this code, `FirstOrDefault(c => c.Type == "username")` finds the first claim where the `Type` is "username". If such a claim exists, `usernameClaim` will be that claim; otherwise, it will be `null`. If `usernameClaim` is not `null`, `usernameClaim.Value` will be the username.§Type ¶StatusØFollowUpPromptsíŸMHow can I handle the case when the token does not contain a "username" claim?Ÿ8What other information can I extract from the JWT token?≥CodeVulnerabilitiesê